/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"

// Configuration Functions

void Init_Systick_Timer();
void Init_Tasks();
void Init_Tasks_Stacks();
__attribute__((naked)) void Change_To_Psp();
__attribute__((naked)) void Init_Scheduler_Stack();

// Task Handler
void Task_Handler_1(void);
void Task_Handler_2(void);
void Task_Handler_3(void);
void Task_Handler_4(void);
void Idle_Task(void);

// Global variables
static uint32_t sys_ticks;
static uint8_t volatile CurrentTaskId;
Task_t tasks[ MAX_NUM_TASKS ];					// Array of tasks

void SetCurrentStackPtr(uint32_t stackAddr);
uint32_t GetCurrentStackPtr();
uint32_t UpdateTask(uint32_t stackAddr);
void SwitchTask();
void DELAY_MS( uint32_t delay  );


int main(){
	sys_ticks = 0;
	// Enable faults
	EN_FAULTS();
	// Enable LEDs
	LED_Setup();
	printf("Enabling fault handlers\n");
	// Set the MSP stack for the Systick
	Init_Scheduler_Stack((uint32_t volatile) SCHEDULER_STACK_START);
	// Instantiate tasks
	Init_Tasks();
	// Instantiate task stacks
	Init_Tasks_Stacks();
	// instantiate the systick timer
	Init_Systick_Timer();
	// Switch to the PSP
	Change_To_Psp();
	// Call the first function
	CurrentTaskId = 0;
	tasks[CurrentTaskId].TaskState = TASK_READY;
	tasks[CurrentTaskId].Operation();
	// Loop on
	for(;;)

	return 0;
}


/**
 * Function to instantiate the sys tick timer
 */
void Init_Systick_Timer(){
	// Configure Systick
	// * Set the clock source
	// * Set to trigger systick on timeout
	// * Enable the counter
	SYSTICK_BLOCK->CSR &= ~0x7;
	SYSTICK_BLOCK->CSR |= 0x7;

	// Set the reload value
	SYSTICK_BLOCK->RVR |= (0xFFFFFF & (GET_SYS_TICK_RELOAD-1) );
}

/**
 * instantiate the task objects with their respective values
 */
void Init_Tasks(){
	// init task Ids
	tasks[0].Id = 0;
	tasks[1].Id = 0;
	tasks[2].Id = 0;
	tasks[3].Id = 0;
	tasks[4].Id = 0;

	// Init Stack pointer
	tasks[0].StackPtr = TASK_1_START;
	tasks[1].StackPtr = TASK_2_START;
	tasks[2].StackPtr = TASK_3_START;
	tasks[3].StackPtr = TASK_4_START;
	tasks[4].StackPtr = IDLE_TASK_START;

	// Init states
	tasks[0].TaskState = TASK_READY;
	tasks[1].TaskState = TASK_READY;
	tasks[2].TaskState = TASK_READY;
	tasks[3].TaskState = TASK_READY;
	tasks[4].TaskState = TASK_READY;
	// Set task operations
	tasks[0].Operation = ToggleLed1;
	tasks[1].Operation = ToggleLed2;
	tasks[2].Operation = ToggleLed3;
	tasks[3].Operation = ToggleLed4;
	tasks[4].Operation = Idle_Task;
}


/**
 * Instantiates the tasks stack pointer with dummy values at first run
 */
void Init_Tasks_Stacks(){

	uint32_t volatile * volatile psp_ptr = NULL;

	for( uint8_t i = 0; i < MAX_NUM_TASKS; i++ ){
		// Get the task's stack pointer
		psp_ptr = (uint32_t volatile *) tasks[i].StackPtr;
		// PSR
		psp_ptr--;
		*psp_ptr = 0x01000000;
		// PC
		psp_ptr--;
		*psp_ptr = (uint32_t) tasks[i].Operation;
		// LR
		psp_ptr--;
		*psp_ptr = 0xFFFFFFFD;
		// Set default values in the stack
		for(uint8_t i = 0; i < 13; i++ ){
			// zero the register
			psp_ptr--;
			*psp_ptr = 0x0;
		}
		// Store the stack updated address
		tasks[i].StackPtr = (uint32_t) psp_ptr;
	}
}

void SetCurrentStackPtr(uint32_t stackAddr){ tasks[ CurrentTaskId ].StackPtr = stackAddr; }

uint32_t GetCurrentStackPtr(){ 	return tasks[ CurrentTaskId ].StackPtr; }

void DELAY_MS( uint32_t delay  ){
	tasks[CurrentTaskId].TaskState = TASK_WAITING;
	tasks[CurrentTaskId].currDelay += (delay);
	SET_PEND_BIT();
}

uint32_t UpdateTask(uint32_t stackAddr){
	// Set current task's stack address value
	SetCurrentStackPtr(stackAddr);
	// Move to next available task
	SwitchTask();
	// return the next stack pointer
	return GetCurrentStackPtr();
}

void SwitchTask(){

	uint8_t i = CurrentTaskId;
	// Check for tasks that are ready to run
	do{
		i++;
		i %= MAX_NUM_TASKS;
	}
	while( tasks[i].TaskState == TASK_WAITING && tasks[i].currDelay > sys_ticks );
	// update curr task id
	CurrentTaskId = i;
}

void ReleaseTasks( ){
	for( uint8_t i = 0; i < MAX_NUM_TASKS; i++ ){
		// Check if the task has timed out
		if(tasks[i].TaskState == TASK_WAITING && tasks[i].currDelay <= sys_ticks){
			tasks[i].TaskState = TASK_READY;
		}
	}
}

/**
 * Switches the Current stack to the PSP stack
 */
__attribute__((naked)) void Change_To_Psp(){
	// Get the current value of the PSP
	__asm volatile("PUSH {LR}");
	__asm volatile("BL GetCurrentStackPtr");
	__asm volatile("MSR PSP, R0");
	__asm volatile("POP {LR}");
	// Set PSP as current stack
	__asm volatile("MOV R0, #0x2");
	__asm volatile("MSR CONTROL, R0");
	__asm volatile("BX LR");
}


/**
 * Points the stack scheduler to the stack
 */
__attribute__((naked)) void Init_Scheduler_Stack( uint32_t volatile scheduler_stack_top ){
	// Move the Scheduler stack to the MSP
	__asm volatile("MSR MSP, R0");
	// branch back to the LR destination
	__asm volatile("BX LR");
}


void Task_Handler_1(void){
	while(1){
		printf("%ld | In task 1\n", sys_ticks);
		DELAY_MS(1000);
	}
}


void Task_Handler_2(void){
	while(1){
		printf("%ld | In task 2\n", sys_ticks);
		DELAY_MS(100);
	}
}
void Task_Handler_3(void){
	while(1){
		printf("%ld | In task 3\n", sys_ticks);
		DELAY_MS(5);
	}
}

void Task_Handler_4(void){
	while(1){
		printf("%ld | In task 4\n", sys_ticks);
		DELAY_MS(4);
	}
}


void Idle_Task(void){
	while(1){ printf("Idle task\n"); }
}

void SysTick_Handler(void){
	// Increment ticks
	sys_ticks++;
	// release tasks that are waiting
	ReleaseTasks();
	// Pend the Pend SV handler
	SET_PEND_BIT();
}

// Context Switching
__attribute__((naked)) void PendSV_Handler(){
	// read in the current PSP value
		__asm volatile("MRS R0, PSP");
		// Push the current task's context to it's stack
		__asm volatile("STMDB R0!, {R4-R11}");
		// Store the LR before jumping to function
		__asm volatile("PUSH {LR}");
		// Update stack of current task
		__asm volatile("BL UpdateTask");
		// Pop the context of the current task stack
		__asm volatile("LDMIA R0!, {R4-R11}");
		// Set the new address of the stack
		__asm volatile("MSR PSP, R0");
		// return from the function
		__asm volatile("POP {LR}");
		__asm volatile("BX LR");
}



//2. implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : Hardfault\n");
	while(1);
}


void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}
